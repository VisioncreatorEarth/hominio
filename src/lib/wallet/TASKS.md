# Lit Protocol Capacity Credits Integration Plan

**Important Note on `datil-dev` Network:** As per Lit Protocol documentation ([Payment Delegation Database](https://developer.litprotocol.com/paying-for-lit/payment-delegation-db)), payment for usage (and thus strict enforcement of Capacity Credits) is **not** required on the `datil-dev` network. The following plan outlines implementing Capacity Credit logic primarily for correctness, future-proofing for mainnet (`datil`) or `datil-test` (where credits are enforced), and to understand the mechanisms. If testing actual rate-limiting effects of Capacity Credits is desired, the `LitNodeClient` configuration would need to switch to `litNetwork: 'datil-test'`.

This plan **avoids** using Lit Protocol's Payment Delegation Database / Relayer Service, opting for manual NFT management and client-side delegation signature handling for testing purposes.

## 1. Status Quo

*   The application currently interacts with the Lit Protocol using the `datil-dev` network (as seen in `connectToLit` in `src/lib/wallet/lit.ts`).
*   PKPs are minted using the `mintPKPWithPasskeyAndAction` function, which registers a Lit Action for passkey verification as an auth method.
*   The current setup does not explicitly manage or utilize Lit Protocol Capacity Credits. Operations might be subject to default, lower rate limits if run on networks where credits are enforced.
*   Session signatures are obtained without specific capacity delegation.

## 2. Wanted Solution

*   **Network Strategy:** Continue using `datil-dev` for `LitNodeClient` interactions, understanding that Capacity Credits won't be enforced. Mint Capacity Credit NFTs on Chronicle, and generate delegation signatures against these Chronicle assets.
*   **Capacity Credit NFT:** A designated master EOA (Ethereum Owned Account), specifically the account associated with the `walletClient` in existing functions like `mintPKPWithPasskeyAndAction`, will be responsible for manually minting and holding a Capacity Credits NFT on the Chronicle testnet.
*   **Automated Delegation (During PKP Minting):** Upon minting a new PKP:
    *   The master EOA (holder of the Capacity Credit NFT) will generate a `capacityDelegationAuthSig` delegating usage rights of its Capacity Credit NFT to the newly minted PKP's Ethereum address.
    *   This delegation signature will be returned to the client to manage.
*   **Session Sigs with Capacity:** When generating session signatures for a PKP, the client will provide the previously obtained and stored `capacityDelegationAuthSig` for that PKP. This will be passed to `getSessionSigs` (or `getLitActionSessionSigs`) via the `capabilityAuthSigs` parameter, ensuring the PKP's operations *could* be counted against delegated capacity on an enforcing network.
*   **Scope of Delegation:** The delegation should allow the PKP to use the capacity for its intended operations (e.g., `pkp-signing` and `lit-action-execution`).

## 3. Local Management for Testing (No Backend Database)

*   **Capacity Credit NFT Token ID (`capacityTokenIdStr`):**
    *   [ ] The master EOA will manually mint a Capacity Credit NFT on the Chronicle testnet using Lit Explorer (or a script using `@lit-protocol/contracts-sdk` if preferred later).
    *   [ ] This `capacityTokenIdStr` will be stored in a secure application configuration (e.g., environment variable) accessible by functions that need to create delegation signatures.
*   **Capacity Delegation Auth Signature (`capacityDelegationAuthSig`):**
    *   [ ] Generated by `litNodeClient.createCapacityDelegationAuthSig` (likely called within an updated `mintPKPWithPasskeyAndAction` or a new dedicated delegation function).
    *   [ ] This AuthSig is specific to a `capacityTokenId` (from config) and `delegateeAddresses` (the new PKP's ETH address).
    *   [ ] The function generating it will return this `capacityDelegationAuthSig` to the caller (client-side).
    *   [ ] For testing, the client-side application code will be responsible for storing this `capacityDelegationAuthSig` (e.g., in browser `localStorage` or a Svelte store, mapping the PKP's address/ID to its `capacityDelegationAuthSig`).
    *   [ ] When session sigs are needed for that specific PKP, the client-side code will retrieve the stored `capacityDelegationAuthSig` and pass it to the relevant `getSessionSigs` function.

## 4. Execution Plan

*   **Task 1: Verify and Finalize Lit Network Configuration.**
    *   [x] Acknowledge `datil-dev` is the current target network for `LitNodeClient` and that payment/capacity credits are not enforced there. Chronicle remains the network for NFT minting and delegation signing.
    *   [ ] Confirm with the user that `datil-dev` is sufficient for this phase of implementing the logic. If testing *enforcement* becomes a priority, `LitNodeClient` instances would need to target `datil-test`.
    *   [ ] Ensure all `LitNodeClient` instantiations consistently use `litNetwork: 'datil-dev'` (or the confirmed target network).
    *   [ ] Update any relevant constants or configuration for network choice if discrepancies are found.

*   **Task 2: Integrate Lit Contracts SDK (for Potential Future Automated Minting - Manual for Now).**
    *   [ ] Add `@lit-protocol/contracts-sdk` as a project dependency.
    *   [ ] (Optional, Low Priority for now) Conceptualize/stub a utility function `mintCapacityCreditNft(walletClient: WalletClient, eoaAddress: Address, requestsPerDay: number, days: number): Promise<string>` in `src/lib/wallet/lit.ts` for future automation of Capacity Credit NFT minting on Chronicle. For now, manual minting via Lit Explorer is sufficient.
        *   This function would use `LitContracts` from the SDK, connect to Chronicle.
        *   The EOA (`walletClient`) must have `tstLPX` tokens on Chronicle.
    *   **Action for now:** Manually mint the Capacity Credit NFT for the master EOA on Chronicle and securely store its `capacityTokenIdStr` in the application config (e.g., `.env`).

*   **Task 3: Implement Capacity Delegation during PKP Minting.**
    *   [ ] Modify the `mintPKPWithPasskeyAndAction` function in `src/lib/wallet/lit.ts` (or create a new wrapper/sub-function for delegation).
    *   [ ] This function will need access to the `capacityTokenIdStr` (from app config) of the master EOA's Capacity Credit NFT.
    *   [ ] **Crucial:** The `dAppOwnerWallet` parameter for `litNodeClient.createCapacityDelegationAuthSig` requires an `ethers.Signer` (e.g., `ethers.Wallet`) that owns the Capacity Credit NFT, as per Lit SDK examples. The current system uses Viem's `WalletClient`.
        *   [ ] Investigate and implement a secure way to obtain an `ethers.Wallet` instance corresponding to the `walletClient` (e.g., if `walletClient` is backed by a private key that can be securely accessed for this specific, trusted operation) OR check if recent versions of `@lit-protocol/lit-node-client` support a Viem `WalletClient` directly as `dAppOwnerWallet` for `createCapacityDelegationAuthSig`.
    *   [ ] Instantiate a `LitNodeClient` (if not already available in scope) configured for `datil-dev` (or the chosen Lit network for this operation, as per Lit docs examples).
    *   [ ] After successfully minting the PKP and obtaining its `pkpEthAddress`, call `litNodeClient.createCapacityDelegationAuthSig`:
        ```typescript
        // const { capacityDelegationAuthSig } = await litNodeClient.createCapacityDelegationAuthSig({
        //   dAppOwnerWallet: ethersCompatibleWalletForEoa, // Must be ethers.Wallet or compatible SignerLike
        //   capacityTokenId: configuredCapacityTokenId,    // From app config
        //   delegateeAddresses: [newPkpEthAddress],
        //   uses: "0", // "0" for unlimited uses, or a specific number. For a PKP, unlimited is likely desired.
        //   expiration: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30).toISOString(), // Example: 30 days
        // });
        ```
    *   [ ] The `mintPKPWithPasskeyAndAction` function (or its caller) should return the `capacityDelegationAuthSig` along with other PKP details.
    *   [ ] The client-side application logic will then store this `capacityDelegationAuthSig` (e.g., in browser local storage) associated with the `pkpEthAddress` or `pkpPublicKey`.

*   **Task 4: Update Session Signature Generation to Use Delegated Capacity.**
    *   [ ] Identify all functions responsible for generating session sigs for PKPs (e.g., `getSessionSigs`, potentially any PKP-specific wrappers).
    *   [ ] Modify these functions to accept an optional `capacityDelegationAuthSig: AuthSig | undefined` parameter.
    *   [ ] When calling these functions from the client-side for a specific PKP, retrieve its stored `capacityDelegationAuthSig` (from local storage/Svelte store) and pass it.
    *   [ ] If `capacityDelegationAuthSig` is provided to `getSessionSigs`, include it in the `litNodeClient.getSessionSigs()` call via the `capabilityAuthSigs` parameter:
        ```typescript
        // const sessionSigs = await litNodeClient.getSessionSigs({
        //   ..., // existing params like chain, resourceAbilityRequests, pkpPublicKey, authNeededCallback
        //   capabilityAuthSigs: capacityDelegationAuthSig ? [capacityDelegationAuthSig] : [],
        // });
        ```

*   **Task 5: Update `getSessionSigsWithGnosisPasskeyVerification` for Capacity Credits.**
    *   [ ] This function calls `litNodeClient.getLitActionSessionSigs`. Review Lit Protocol documentation to confirm how `capacityDelegationAuthSig` is used with `getLitActionSessionSigs` (it should be via the `capabilityAuthSigs` parameter, similar to `getSessionSigs`).
    *   [ ] Add `capacityDelegationAuthSig: AuthSig | undefined` as an optional parameter to `getSessionSigsWithGnosisPasskeyVerification`.
    *   [ ] If provided, pass it through to `litNodeClient.getLitActionSessionSigs` via the `capabilityAuthSigs` parameter:
        ```typescript
        // const sessionSigs = await litNodeClient.getLitActionSessionSigs({
        //   ..., // existing params like pkpPublicKey, litActionCode, jsParams, chain, resourceAbilityRequests
        //   capabilityAuthSigs: capacityDelegationAuthSig ? [capacityDelegationAuthSig] : [],
        // });
        ```

*   **Task 6: Testing and Validation.**
    *   [ ] Manually mint a Capacity Credit NFT on Chronicle for the master EOA using Lit Explorer. Record the `capacityTokenIdStr`.
    *   [ ] Configure this `capacityTokenIdStr` in the application (e.g., `.env` file).
    *   [ ] Test the modified `mintPKPWithPasskeyAndAction` flow:
        *   Ensure it mints the PKP.
        *   Ensure it successfully calls `createCapacityDelegationAuthSig` and returns the auth sig.
        *   Verify the client-side stores the `capacityDelegationAuthSig` correctly (e.g., in local storage).
    *   [ ] Test session signature generation for the new PKP, ensuring the client retrieves and passes the stored `capacityDelegationAuthSig`.
    *   [ ] Perform operations with the PKP (signing, Lit Action execution). While `datil-dev` won't enforce limits, ensure the calls succeed with the `capacityDelegationAuthSig` included.
    *   (Optional) To test actual enforcement: temporarily switch `LitNodeClient` to `datil-test`, ensure the Capacity Credit NFT is also usable on `datil-test` (or mint one specifically for it), and observe behavior.

*   **Task 7: Documentation and Configuration Management.**
    *   [ ] Document the new requirement for the master EOA to hold a Capacity Credit NFT and how its `capacityTokenIdStr` is configured.
    *   [ ] Document the client-side strategy for storing and retrieving `capacityDelegationAuthSig` for PKPs during testing.
    *   [ ] Update comments in `src/lib/wallet/lit.ts` to reflect the new Capacity Credit logic and the `ethers.Signer` requirement for delegation. 